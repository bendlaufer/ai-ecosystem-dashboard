<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>AI Ecosystem 3D Network Visualization</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="icon" type="image/svg+xml" href="favicon.svg" sizes="any">
    <script>
        // Force cache refresh - version 2
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.getRegistrations().then(function(registrations) {
                for(let registration of registrations) {
                    registration.unregister();
                }
            });
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 350px;
            z-index: 100;
        }
        
        #controls h2 {
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
            font-size: 14px;
        }
        
        input[type="text"],
        input[type="range"],
        select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        
        input[type="range"] {
            padding: 0;
        }
        
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .checkbox-item input[type="checkbox"] {
            width: auto;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
            margin-top: 10px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #5568d3;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 16px;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        #info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 300px;
            display: none;
            z-index: 100;
        }
        
        #info-panel h3 {
            margin-bottom: 10px;
            color: #333;
        }
        
        #info-panel p {
            font-size: 12px;
            color: #666;
            line-height: 1.6;
        }
        
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-size: 12px;
            z-index: 100;
        }
        
        #stats div {
            margin-bottom: 5px;
        }
        
        .edge-type-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }
        
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        <div class="loading" id="loading">Loading graph data...</div>
        
        <div id="controls">
            <h2>AI Ecosystem Dashboard</h2>
            <p style="font-size: 12px; color: #666; margin-bottom: 15px;">
                Explore the AI model ecosystem network in 3D
            </p>
            
            <div class="control-group">
                <label for="search">Enter Model ID:</label>
                <input type="text" id="search" placeholder="Enter model ID (e.g., zera09/SmolVLM)">
                <button id="search-btn" style="margin-top: 5px;">Load Component</button>
            </div>
            
            <div class="control-group">
                <label>Current Component:</label>
                <p id="component-info" style="font-size: 12px; color: #666; margin-top: 5px;">
                    Search for a model ID to load its connected component
                </p>
            </div>
            
            <div class="control-group">
                <label>Edge Types:</label>
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="filter-finetune" checked>
                        <span class="edge-type-color" style="background: #ff6b6b;"></span>
                        <label for="filter-finetune">Finetune</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="filter-quantized" checked>
                        <span class="edge-type-color" style="background: #4ecdc4;"></span>
                        <label for="filter-quantized">Quantized</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="filter-adapter" checked>
                        <span class="edge-type-color" style="background: #45b7d1;"></span>
                        <label for="filter-adapter">Adapter</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="filter-unknown" checked>
                        <span class="edge-type-color" style="background: #96ceb4;"></span>
                        <label for="filter-unknown">Other</label>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="edge-opacity">Edge Opacity: <span id="edge-opacity-value">0.5</span></label>
                <input type="range" id="edge-opacity" min="0" max="1" step="0.1" value="0.5">
            </div>
        </div>
        
        <div id="info-panel">
            <h3 id="node-name"></h3>
            <p id="node-details"></p>
        </div>
        
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Configuration
        const CONFIG = {
            nodeBaseSize: 0.5,
            edgeOpacity: 0.5,
            cameraDistance: 50,
            animationSpeed: 0.02
        };
        
        // CDN Configuration - Update this with your GitHub Release URL after uploading
        // Format: https://github.com/bendlaufer/ai-ecosystem-dashboard/releases/download/v1.0/graph_data.json
        // 
        // IMPORTANT: GitHub Releases may not have CORS headers. Options:
        // 1. Use a CORS proxy (see CDN_SETUP.md for details)
        // 2. Use a proper CDN like Cloudflare R2, AWS S3, etc.
        // 3. For testing: Use a CORS proxy service like allorigins.win
        //
        // Example with CORS proxy:
        // const CDN_URL = 'https://api.allorigins.win/raw?url=' + encodeURIComponent('https://github.com/bendlaufer/ai-ecosystem-dashboard/releases/download/v1.0/graph_data.json');
        //
        // Using CORS proxy to access GitHub Releases (works immediately)
        // CDN Configuration for Full Dataset
        // Using gzip-compressed version (56MB instead of 569MB) - much faster!
        
        // CDN Configuration - Cloudflare Worker with CORS
        // Using Cloudflare Worker to proxy R2 with proper CORS headers
        const CDN_URL = 'https://ai-ecosystem-graph-proxy.bdl56.workers.dev';
        
        // Fallback: R2 Public Development URL (if custom domain has issues)
        // const CDN_URL = 'https://pub-89cf9135be2346638e77c9edf35edf5a.r2.dev/graph_data.json.gz';
        
        // Alternative: GitHub Releases via CORS proxy (may timeout on 57MB files)
        // const GITHUB_RELEASE_URL = 'https://github.com/bendlaufer/ai-ecosystem-dashboard/releases/download/v1.0/graph_data.json.gz';
        // const CDN_URL = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(GITHUB_RELEASE_URL);
        
        // Global variables
        let scene, camera, renderer, controls;
        let nodeMeshes = [];
        let edgeLines = [];
        let nodes = [];
        let edges = [];
        let nodeMap = new Map();
        // NO client-side index - use server-side APIs instead
        // This prevents loading 1.86M entries into browser memory
        let graphData = null;  // Currently loaded component data
        let useFullDataset = true;  // Always use full dataset
        let selectedNode = null;
        let raycaster, mouse;
        let animationId;
        let hasChildren = new Set();  // Track which nodes have children (for color management)
        
        // Edge type colors
        const EDGE_COLORS = {
            'finetune': 0xff6b6b,
            'quantized': 0x4ecdc4,
            'adapter': 0x45b7d1,
            'unknown': 0x96ceb4,
            'default': 0xcccccc
        };
        
        // Initialize
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, CONFIG.cameraDistance);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            
            // Add controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 200;
            
            // Raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Handle mouse clicks
            renderer.domElement.addEventListener('click', onMouseClick);
            
            // UI controls
            setupUIControls();
            
            // Load initial data
            loadGraphData();
        }
        
        // Look up component_id for a model using server-side API (no client-side index needed)
        async function lookupComponentId(modelId) {
            try {
                const response = await fetch(`${CDN_URL}/lookup?model_id=${encodeURIComponent(modelId)}`, {
                    method: 'GET',
                    mode: 'cors'
                });
                
                if (!response.ok) {
                    if (response.status === 404) {
                        return null; // Model not found
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                return data.component_id || null;
            } catch (error) {
                console.error('Error looking up component:', error);
                throw error;
            }
        }
        
        // Load a specific component by component_id
        async function loadComponentById(componentId) {
            try {
                console.log(`Loading component ${componentId}...`);
                document.getElementById('loading').textContent = `Loading component ${componentId}...`;
                
                const componentUrl = `${CDN_URL}/component_${componentId}.json.gz`;
                const response = await fetch(componentUrl, {
                    method: 'GET',
                    mode: 'cors',
                    cache: 'default'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                // Decompress gzip
                const compressedData = await response.arrayBuffer();
                const stream = new DecompressionStream('gzip');
                const decompressedStream = new Response(compressedData).body.pipeThrough(stream);
                const decompressedData = await new Response(decompressedStream).arrayBuffer();
                const jsonText = new TextDecoder().decode(decompressedData);
                
                const componentData = JSON.parse(jsonText);
                
                console.log('Component loaded:', componentData.nodes.length, 'nodes,', componentData.edges.length, 'edges');
                
                return componentData;
            } catch (error) {
                console.error(`Error loading component ${componentId}:`, error);
                throw error;
            }
        }
        
        // Load component for a given model ID (uses server-side lookup)
        async function loadComponentForModel(modelId) {
            // Look up component_id using server-side API
            const componentId = await lookupComponentId(modelId);
            
            if (componentId === null || componentId === undefined) {
                throw new Error(`Model "${modelId}" not found`);
            }
            
            const componentData = await loadComponentById(componentId);
            return componentData;
        }
        
        // Initial load: Load component 192 (zera09/SmolVLM) by default
        async function loadGraphData() {
            // Always start with component 192 (contains zera09/SmolVLM)
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loading').textContent = 'Loading component 192 (zera09/SmolVLM)...';
            
            try {
                graphData = await loadComponentById(192);
                
                document.getElementById('component-info').textContent = 
                    `${graphData.nodes.length} nodes, ${graphData.edges.length} edges (zera09/SmolVLM)`;
                
                createGraph();
                // Restart animation for new graph - ensure it starts
                if (animationId === null && nodes.length > 0) {
                    animate();
                }
                // Force initial render
                controls.update();
                renderer.render(scene, camera);
                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                console.error('Error loading default component:', error);
                document.getElementById('loading').textContent = `Error loading component: ${error.message}`;
                document.getElementById('loading').style.display = 'block';
            }
        }
        
        // Note: findConnectedComponent removed - components are now loaded directly from R2
        
        // Create graph visualization
        function createGraph() {
            console.log('Creating graph visualization...');
            
            // Stop animation loop before cleanup to prevent multiple loops
            if (animationId !== null && animationId !== undefined) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            // Clear existing and dispose Three.js resources to prevent memory leaks
            // Remove only graph objects (meshes and lines) from scene
            const objectsToRemove = [];
            scene.traverse((obj) => {
                if (obj.type === 'Mesh' || obj.type === 'Line') {
                    objectsToRemove.push(obj);
                }
            });
            
            objectsToRemove.forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => mat.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
            });
            
            // Also explicitly remove from arrays and dispose
            nodeMeshes.forEach(mesh => {
                if (scene.children.includes(mesh)) {
                    scene.remove(mesh);
                }
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) {
                    if (Array.isArray(mesh.material)) {
                        mesh.material.forEach(mat => mat.dispose());
                    } else {
                        mesh.material.dispose();
                    }
                }
            });
            
            edgeLines.forEach(line => {
                if (scene.children.includes(line)) {
                    scene.remove(line);
                }
                if (line.geometry) line.geometry.dispose();
                if (line.material) {
                    if (Array.isArray(line.material)) {
                        line.material.forEach(mat => mat.dispose());
                    } else {
                        line.material.dispose();
                    }
                }
            });
            
            // Clear arrays and reset all state
            nodeMeshes = [];
            edgeLines = [];
            nodes = [];
            edges = [];
            nodeMap.clear();
            
            // Reset animation state
            animationId = null;
            
            console.log(`Scene cleared. Children count: ${scene.children.length}`);
            
            // Force garbage collection hint (if available)
            if (window.gc) {
                window.gc();
            }
            
            // If no graph data, return early
            if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
                console.log('No graph data to visualize');
                return;
            }
            
            // Create node map
            graphData.nodes.forEach(node => {
                nodeMap.set(node.id, node);
            });
            
            // Find root nodes (nodes with no incoming edges) for better initial positioning
            const rootNodes = new Set();
            graphData.nodes.forEach(node => {
                const hasIncoming = graphData.edges.some(edge => edge.target === node.id);
                if (!hasIncoming) {
                    rootNodes.add(node.id);
                }
            });
            
            // If no root nodes found, use first node as root
            if (rootNodes.size === 0 && graphData.nodes.length > 0) {
                rootNodes.add(graphData.nodes[0].id);
            }
            
            // Build map of which nodes have children
            hasChildren.clear();
            graphData.edges.forEach(edge => {
                hasChildren.add(edge.source);
            });
            
            // Size parameters: nodes with children are 3x the diameter of leaf nodes
            const leafModelSize = CONFIG.nodeBaseSize * 0.5;
            const parentModelSize = leafModelSize * 3.0;
            
            // Create nodes
            graphData.nodes.forEach((nodeData, index) => {
                const isParent = hasChildren.has(nodeData.id);
                const size = isParent ? parentModelSize : leafModelSize;
                
                const geometry = new THREE.SphereGeometry(size, 16, 16);
                const material = new THREE.MeshPhongMaterial({
                    color: isParent ? 0xff6b6b : 0x4ecdc4,
                    emissive: isParent ? 0x330000 : 0x003333,
                    transparent: true,
                    opacity: 0.9
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                
                // Random initial position (will be updated by force simulation)
                mesh.position.set(
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20
                );
                
                mesh.userData = { nodeData, index };
                scene.add(mesh);
                nodeMeshes.push(mesh);
                nodes.push({ mesh, nodeData, velocity: new THREE.Vector3() });
            });
            
            // Create edges
            const edgeOpacity = parseFloat(document.getElementById('edge-opacity').value);
            graphData.edges.forEach(edge => {
                const sourceNode = nodes.find(n => n.nodeData.id === edge.source);
                const targetNode = nodes.find(n => n.nodeData.id === edge.target);
                
                if (!sourceNode || !targetNode) return;
                
                const edgeType = edge.type || 'unknown';
                const color = EDGE_COLORS[edgeType] || EDGE_COLORS['default'];
                
                const geometry = new THREE.BufferGeometry().setFromPoints([
                    sourceNode.mesh.position,
                    targetNode.mesh.position
                ]);
                
                const material = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: edgeOpacity
                });
                
                const line = new THREE.Line(geometry, material);
                line.userData = { edge, edgeType };
                scene.add(line);
                edgeLines.push(line);
            });
            
            
            // Center camera on graph
            if (nodes.length > 0) {
                const center = new THREE.Vector3();
                nodes.forEach(n => center.add(n.mesh.position));
                center.divideScalar(nodes.length);
                
                camera.position.set(center.x, center.y, center.z + CONFIG.cameraDistance);
                controls.target.copy(center);
                controls.update();
            }
            
            console.log(`Graph created: ${nodes.length} nodes, ${edgeLines.length} edges, scene children: ${scene.children.length}`);
        }
        
        // Simple force-directed layout
        function updateLayout(iterations = 1) {
            if (nodes.length === 0) return;
            
            const nodeCount = nodes.length;
            const isLargeGraph = nodeCount > 1000;
            
            // Adaptive force parameters based on graph size
            // For large graphs, use smaller forces and higher damping for stability
            const baseRepulsion = isLargeGraph ? 0.05 : 0.1;
            const baseAttraction = isLargeGraph ? 0.005 : 0.01;
            const damping = isLargeGraph ? 0.85 : 0.9; // Higher damping for large graphs
            
            // Scale forces inversely with graph size to prevent explosion
            const repulsion = baseRepulsion / Math.sqrt(nodeCount / 100);
            const attraction = baseAttraction;
            const k = Math.sqrt((nodeCount * 100) / nodeCount);
            
            let maxVelocity = 0;
            
            // Run multiple iterations for large graphs to converge faster
            for (let iter = 0; iter < iterations; iter++) {
                // Reset forces and apply damping
                nodes.forEach(node => {
                    if (!node.velocity) {
                        node.velocity = new THREE.Vector3();
                    }
                    node.velocity.multiplyScalar(damping);
                });
                
                // Repulsion between all nodes
                // For very large graphs, we could optimize this, but let's try adaptive forces first
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const nodeA = nodes[i];
                        const nodeB = nodes[j];
                        const distance = nodeA.mesh.position.distanceTo(nodeB.mesh.position);
                        
                        if (distance > 0) {
                            // Use a softer repulsion that doesn't explode at small distances
                            const force = repulsion / (distance * distance + 1);
                            const direction = new THREE.Vector3()
                                .subVectors(nodeA.mesh.position, nodeB.mesh.position)
                                .normalize()
                                .multiplyScalar(force);
                            
                            nodeA.velocity.add(direction);
                            nodeB.velocity.sub(direction);
                        }
                    }
                }
                
                // Attraction along edges
                graphData.edges.forEach(edge => {
                    const sourceNode = nodes.find(n => n.nodeData.id === edge.source);
                    const targetNode = nodes.find(n => n.nodeData.id === edge.target);
                    
                    if (!sourceNode || !targetNode) return;
                    
                    const distance = sourceNode.mesh.position.distanceTo(targetNode.mesh.position);
                    if (distance > 0) {
                        const force = (distance - k) * attraction;
                        const direction = new THREE.Vector3()
                            .subVectors(targetNode.mesh.position, sourceNode.mesh.position)
                            .normalize()
                            .multiplyScalar(force);
                        
                        sourceNode.velocity.add(direction);
                        targetNode.velocity.sub(direction);
                    }
                });
                
                // Update positions and track max velocity
                nodes.forEach(node => {
                    node.mesh.position.add(node.velocity);
                    const vel = node.velocity.length();
                    if (vel > maxVelocity) maxVelocity = vel;
                });
            }
            
            // Update edge positions
            edgeLines.forEach(line => {
                const edge = line.userData.edge;
                const sourceNode = nodes.find(n => n.nodeData.id === edge.source);
                const targetNode = nodes.find(n => n.nodeData.id === edge.target);
                
                if (sourceNode && targetNode) {
                    line.geometry.setFromPoints([
                        sourceNode.mesh.position,
                        targetNode.mesh.position
                    ]);
                }
            });
            
            return maxVelocity;
        }
        
        // Pre-compute layout for large graphs
        async function precomputeLayout(maxIterations = 500, stabilityThreshold = 0.01) {
            if (nodes.length === 0) return;
            
            const isLargeGraph = nodes.length > 1000;
            if (!isLargeGraph) return; // Only pre-compute for large graphs
            
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loading').textContent = `Computing layout for ${nodes.length} nodes...`;
            
            // Use requestAnimationFrame to avoid blocking the UI
            return new Promise((resolve) => {
                let iterations = 0;
                let stableCount = 0;
                const requiredStableIterations = 10; // Consider stable after 10 low-velocity iterations
                
                function computeStep() {
                    const maxVelocity = updateLayout(isLargeGraph ? 5 : 1); // Multiple iterations per frame for large graphs
                    iterations++;
                    
                    // Check if layout is stable (low velocities)
                    if (maxVelocity < stabilityThreshold) {
                        stableCount++;
                        if (stableCount >= requiredStableIterations) {
                            document.getElementById('loading').style.display = 'none';
                            resolve();
                            return;
                        }
                    } else {
                        stableCount = 0; // Reset if not stable
                    }
                    
                    // Stop after max iterations even if not fully stable
                    if (iterations >= maxIterations) {
                        document.getElementById('loading').style.display = 'none';
                        resolve();
                        return;
                    }
                    
                    // Update progress for very large graphs
                    if (iterations % 50 === 0 && nodes.length > 5000) {
                        const progress = Math.min(100, Math.round((iterations / maxIterations) * 100));
                        document.getElementById('loading').textContent = `Computing layout... ${progress}%`;
                    }
                    
                    requestAnimationFrame(computeStep);
                }
                
                computeStep();
            });
        }
        
        // Animation loop
        function animate() {
            // Only continue if we have nodes to animate
            if (nodes.length === 0) {
                animationId = null;
                return;
            }
            
            animationId = requestAnimationFrame(animate);
            
            // For large graphs that were pre-computed, use minimal animation
            // For smaller graphs, normal animation
            const isLargeGraph = nodes.length > 1000;
            const maxVelocity = updateLayout(isLargeGraph ? 1 : 1);
            
            // Stop animation if layout is stable (for large graphs)
            if (isLargeGraph && maxVelocity < 0.01) {
                // Still update edges and render, but don't continue animating
                controls.update();
                renderer.render(scene, camera);
                return; // Don't continue animation loop
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Handle mouse click
        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodeMeshes);
            
            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object;
                const nodeData = clickedMesh.userData.nodeData;
                
                // If clicking the same node, do nothing
                if (selectedNode === clickedMesh) {
                    return;
                }
                
                // Deselect old node if one is selected
                if (selectedNode) {
                    const oldNodeData = selectedNode.userData.nodeData;
                    // Reset to original emissive color based on whether it has children
                    selectedNode.material.emissive.setHex(
                        hasChildren.has(oldNodeData.id) ? 0x330000 : 0x003333
                    );
                }
                
                // Select new node
                clickedMesh.material.emissive.setHex(0xffff00);
                selectedNode = clickedMesh;
                
                showNodeInfo(nodeData);
            } else {
                // Clicked outside any node - deselect
                hideNodeInfo();
                if (selectedNode) {
                    const oldNodeData = selectedNode.userData.nodeData;
                    // Reset to original emissive color based on whether it has children
                    selectedNode.material.emissive.setHex(
                        hasChildren.has(oldNodeData.id) ? 0x330000 : 0x003333
                    );
                    selectedNode = null;
                }
            }
        }
        
        // Show node info
        function showNodeInfo(nodeData) {
            const infoPanel = document.getElementById('info-panel');
            // Always show the full model ID (including the part before "/")
            document.getElementById('node-name').textContent = nodeData.id || nodeData.name || 'Unknown Model';
            
            const details = [];
            if (nodeData.likes) details.push(`Likes: ${nodeData.likes.toLocaleString()}`);
            if (nodeData.downloads) details.push(`Downloads: ${nodeData.downloads.toLocaleString()}`);
            if (nodeData.pipeline_tag) details.push(`Type: ${nodeData.pipeline_tag}`);
            if (nodeData.library_name) details.push(`Library: ${nodeData.library_name}`);
            
            document.getElementById('node-details').textContent = details.join(' â€¢ ');
            infoPanel.style.display = 'block';
        }
        
        // Hide node info
        function hideNodeInfo() {
            document.getElementById('info-panel').style.display = 'none';
        }
        
        // Setup UI controls
        function setupUIControls() {
            // Search functionality
            const searchInput = document.getElementById('search');
            const searchBtn = document.getElementById('search-btn');
            
            // Allow Enter key to trigger search
            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const query = searchInput.value.trim();
                    if (query) {
                        loadComponent(query);
                    }
                }
            });
            
            searchBtn.addEventListener('click', () => {
                const query = searchInput.value.trim();
                if (query) {
                    loadComponent(query);
                }
            });
            
            // Edge opacity
            document.getElementById('edge-opacity').addEventListener('input', (e) => {
                const opacity = parseFloat(e.target.value);
                document.getElementById('edge-opacity-value').textContent = opacity.toFixed(1);
                edgeLines.forEach(line => {
                    line.material.opacity = opacity;
                });
            });
            
            // Edge type filters
            ['filter-finetune', 'filter-quantized', 'filter-adapter', 'filter-unknown'].forEach(filterId => {
                document.getElementById(filterId).addEventListener('change', updateEdgeVisibility);
            });
        }
        
        // Load component for a given model ID (async, loads from R2)
        async function loadComponent(nodeId) {
            // Always use server-side lookup API
            
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loading').textContent = `Loading component for ${nodeId}...`;
            
            try {
                graphData = await loadComponentForModel(nodeId);
                
                document.getElementById('component-info').textContent = 
                    `${graphData.nodes.length} nodes, ${graphData.edges.length} edges (${nodeId})`;
                
                createGraph();
                // Restart animation for new graph - ensure it starts
                if (animationId === null && nodes.length > 0) {
                    animate();
                }
                // Force initial render
                controls.update();
                renderer.render(scene, camera);
                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                alert(`Model "${nodeId}" not found: ${error.message}`);
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        // Update edge visibility based on filters
        function updateEdgeVisibility() {
            const showFinetune = document.getElementById('filter-finetune').checked;
            const showQuantized = document.getElementById('filter-quantized').checked;
            const showAdapter = document.getElementById('filter-adapter').checked;
            const showUnknown = document.getElementById('filter-unknown').checked;
            
            edgeLines.forEach(line => {
                const edgeType = line.userData.edgeType || 'unknown';
                let visible = false;
                
                if (edgeType === 'finetune' && showFinetune) visible = true;
                else if (edgeType === 'quantized' && showQuantized) visible = true;
                else if (edgeType === 'adapter' && showAdapter) visible = true;
                else if (showUnknown) visible = true;
                
                line.visible = visible;
            });
        }
        
        // Start the application
        init();
    </script>
</body>
</html>

