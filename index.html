<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>AI Ecosystem 3D Network Visualization</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="icon" type="image/svg+xml" href="favicon.svg" sizes="any">
    <script>
        // Force cache refresh - version 2
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.getRegistrations().then(function(registrations) {
                for(let registration of registrations) {
                    registration.unregister();
                }
            });
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 350px;
            z-index: 100;
        }
        
        #controls h2 {
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
            font-size: 14px;
        }
        
        input[type="text"],
        input[type="range"],
        select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        
        input[type="range"] {
            padding: 0;
        }
        
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .checkbox-item input[type="checkbox"] {
            width: auto;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
            margin-top: 10px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #5568d3;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 16px;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        #info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 300px;
            display: none;
            z-index: 100;
        }
        
        #info-panel h3 {
            margin-bottom: 10px;
            color: #333;
        }
        
        #info-panel p {
            font-size: 12px;
            color: #666;
            line-height: 1.6;
        }
        
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-size: 12px;
            z-index: 100;
        }
        
        #stats div {
            margin-bottom: 5px;
        }
        
        .edge-type-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }
        
        .autocomplete-container {
            position: relative;
        }
        
        #autocomplete-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 5px 5px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 200;
            display: none;
        }
        
        .autocomplete-item {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }
        
        .autocomplete-item:hover {
            background: #f5f5f5;
        }
        
        .autocomplete-item:last-child {
            border-bottom: none;
        }
        
        .autocomplete-item .model-id {
            font-weight: 600;
            color: #333;
        }
        
        .autocomplete-item .model-name {
            color: #666;
            font-size: 12px;
            margin-top: 2px;
        }
        
        .autocomplete-item .highlight {
            background: #fff3cd;
            font-weight: 600;
        }
        
        .data-source-selector {
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        
        .data-source-selector label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
            font-size: 14px;
        }
        
        .data-source-selector select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        <div class="loading" id="loading">Loading graph data...</div>
        
        <div id="controls">
            <h2>AI Ecosystem Dashboard</h2>
            <p style="font-size: 12px; color: #666; margin-bottom: 15px;">
                Explore the AI model ecosystem network in 3D
            </p>
            
            <div class="data-source-selector">
                <label for="data-source">Data Source:</label>
                <select id="data-source">
                    <option value="mini">Mini Sample (zera09/SmolVLM component)</option>
                    <option value="full">Full Dataset (search all models)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="search">Search Model ID:</label>
                <div class="autocomplete-container">
                    <input type="text" id="search" placeholder="Type to search... (e.g., zera09/SmolVLM)">
                    <div id="autocomplete-results"></div>
                </div>
                <button id="search-btn" style="margin-top: 5px;">Search & Load Component</button>
            </div>
            
            <div class="control-group">
                <label>Current Component:</label>
                <p id="component-info" style="font-size: 12px; color: #666; margin-top: 5px;">
                    Search for a model ID to load its connected component
                </p>
            </div>
            
            <div class="control-group">
                <label>Edge Types:</label>
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="filter-finetune" checked>
                        <span class="edge-type-color" style="background: #ff6b6b;"></span>
                        <label for="filter-finetune">Finetune</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="filter-quantized" checked>
                        <span class="edge-type-color" style="background: #4ecdc4;"></span>
                        <label for="filter-quantized">Quantized</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="filter-adapter" checked>
                        <span class="edge-type-color" style="background: #45b7d1;"></span>
                        <label for="filter-adapter">Adapter</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="filter-unknown" checked>
                        <span class="edge-type-color" style="background: #96ceb4;"></span>
                        <label for="filter-unknown">Other</label>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="edge-opacity">Edge Opacity: <span id="edge-opacity-value">0.3</span></label>
                <input type="range" id="edge-opacity" min="0" max="1" step="0.1" value="0.3">
            </div>
        </div>
        
        <div id="info-panel">
            <h3 id="node-name"></h3>
            <p id="node-details"></p>
        </div>
        
        <div id="stats">
            <div><strong>Nodes:</strong> <span id="node-count">0</span></div>
            <div><strong>Edges:</strong> <span id="edge-count">0</span></div>
            <div><strong>Selected:</strong> <span id="selected-count">0</span></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Configuration
        const CONFIG = {
            nodeBaseSize: 0.5,
            edgeOpacity: 0.3,
            cameraDistance: 50,
            animationSpeed: 0.02
        };
        
        // CDN Configuration - Update this with your GitHub Release URL after uploading
        // Format: https://github.com/bendlaufer/ai-ecosystem-dashboard/releases/download/v1.0/graph_data.json
        // 
        // IMPORTANT: GitHub Releases may not have CORS headers. Options:
        // 1. Use a CORS proxy (see CDN_SETUP.md for details)
        // 2. Use a proper CDN like Cloudflare R2, AWS S3, etc.
        // 3. For testing: Use a CORS proxy service like allorigins.win
        //
        // Example with CORS proxy:
        // const CDN_URL = 'https://api.allorigins.win/raw?url=' + encodeURIComponent('https://github.com/bendlaufer/ai-ecosystem-dashboard/releases/download/v1.0/graph_data.json');
        //
        // Using CORS proxy to access GitHub Releases (works immediately)
        // CDN Configuration for Full Dataset
        // Using gzip-compressed version (56MB instead of 569MB) - much faster!
        
        // CDN Configuration - Cloudflare Worker with CORS
        // Using Cloudflare Worker to proxy R2 with proper CORS headers
        const CDN_URL = 'https://ai-ecosystem-graph-proxy.bdl56.workers.dev';
        
        // Fallback: R2 Public Development URL (if custom domain has issues)
        // const CDN_URL = 'https://pub-89cf9135be2346638e77c9edf35edf5a.r2.dev/graph_data.json.gz';
        
        // Alternative: GitHub Releases via CORS proxy (may timeout on 57MB files)
        // const GITHUB_RELEASE_URL = 'https://github.com/bendlaufer/ai-ecosystem-dashboard/releases/download/v1.0/graph_data.json.gz';
        // const CDN_URL = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(GITHUB_RELEASE_URL);
        
        // Global variables
        let scene, camera, renderer, controls;
        let nodeMeshes = [];
        let edgeLines = [];
        let nodes = [];
        let edges = [];
        let nodeMap = new Map();
        // NO client-side index - use server-side APIs instead
        // This prevents loading 1.86M entries into browser memory
        let graphData = null;  // Currently loaded component data
        let useFullDataset = false;  // Toggle between mini and full dataset
        let selectedNode = null;
        let raycaster, mouse;
        let animationId;
        
        // Edge type colors
        const EDGE_COLORS = {
            'finetune': 0xff6b6b,
            'quantized': 0x4ecdc4,
            'adapter': 0x45b7d1,
            'unknown': 0x96ceb4,
            'default': 0xcccccc
        };
        
        // Initialize
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, CONFIG.cameraDistance);
            
            // Create renderer with error handling and fallback options
            const container = document.getElementById('canvas-container');
            // Remove existing canvas if present
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            
            // First, test if WebGL is actually available
            const testCanvas = document.createElement('canvas');
            const testGl = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl') || testCanvas.getContext('webgl2');
            if (!testGl) {
                alert('WebGL is not supported or is disabled in your browser. Please enable WebGL in your browser settings or try a different browser like Chrome, Firefox, or Safari.');
                return;
            }
            
            // Try creating renderer with different configurations
            let rendererCreated = false;
            const rendererConfigs = [
                { antialias: true, powerPreference: "high-performance", preserveDrawingBuffer: false },
                { antialias: false, powerPreference: "high-performance", preserveDrawingBuffer: false },
                { antialias: false, preserveDrawingBuffer: false },
                {} // Minimal config
            ];
            
            for (const config of rendererConfigs) {
                try {
                    renderer = new THREE.WebGLRenderer(config);
                    rendererCreated = true;
                    console.log('WebGL renderer created successfully with config:', config);
                    break;
                } catch (error) {
                    console.warn('Failed to create renderer with config:', config, error);
                    continue;
                }
            }
            
            if (!rendererCreated) {
                console.error('All renderer creation attempts failed');
                alert('Failed to create WebGL renderer. This may be due to:\n- WebGL being disabled in browser settings\n- GPU driver issues\n- Browser compatibility\n\nPlease try refreshing the page or using a different browser.');
                return;
            }
            
            // Configure renderer
            try {
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2)); // Cap pixel ratio for performance
                container.appendChild(renderer.domElement);
            } catch (error) {
                console.error('Failed to configure renderer:', error);
                alert('Failed to configure WebGL renderer. Please refresh the page.');
                return;
            }
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            
            // Add controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 200;
            
            // Raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Handle mouse clicks
            renderer.domElement.addEventListener('click', onMouseClick);
            
            // UI controls
            setupUIControls();
            
            // Load initial data
            loadGraphData();
        }
        
        // Search models - uses server-side API for full dataset, local search for mini
        async function searchModels(query, limit = 10) {
            if (!useFullDataset) {
                // Search in mini dataset (client-side, fast)
                if (!graphData || !graphData.nodes) return [];
                
                const queryLower = query.toLowerCase();
                const matches = [];
                
                for (const node of graphData.nodes) {
                    if (node.id && node.id.toLowerCase().includes(queryLower)) {
                        matches.push({
                            id: node.id,
                            name: node.id.split('/').pop()
                        });
                        if (matches.length >= limit) break;
                    }
                }
                
                return matches;
            } else {
                // Search in full dataset (server-side API)
                try {
                    const response = await fetch(`${CDN_URL}/search?q=${encodeURIComponent(query)}&limit=${limit}`, {
                        method: 'GET',
                        mode: 'cors'
                    });
                    
                    if (!response.ok) {
                        console.warn('Search API failed, returning empty results');
                        return [];
                    }
                    
                    const data = await response.json();
                    return data.matches || data.results || [];
                } catch (error) {
                    console.error('Error searching models:', error);
                    return [];
                }
            }
        }
        
        // Look up component_id for a model using server-side API (no client-side index needed)
        async function lookupComponentId(modelId) {
            try {
                const response = await fetch(`${CDN_URL}/lookup?model_id=${encodeURIComponent(modelId)}`, {
                    method: 'GET',
                    mode: 'cors'
                });
                
                if (!response.ok) {
                    if (response.status === 404) {
                        return null; // Model not found
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                return data.component_id || null;
            } catch (error) {
                console.error('Error looking up component:', error);
                throw error;
            }
        }
        
        // Load a specific component by component_id
        async function loadComponentById(componentId) {
            try {
                console.log(`Loading component ${componentId}...`);
                document.getElementById('loading').textContent = `Loading component ${componentId}...`;
                
                const componentUrl = `${CDN_URL}/component_${componentId}.json.gz`;
                const response = await fetch(componentUrl, {
                    method: 'GET',
                    mode: 'cors',
                    cache: 'default'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                // Decompress gzip
                const compressedData = await response.arrayBuffer();
                const stream = new DecompressionStream('gzip');
                const decompressedStream = new Response(compressedData).body.pipeThrough(stream);
                const decompressedData = await new Response(decompressedStream).arrayBuffer();
                const jsonText = new TextDecoder().decode(decompressedData);
                
                const componentData = JSON.parse(jsonText);
                
                console.log('Component loaded:', componentData.nodes.length, 'nodes,', componentData.edges.length, 'edges');
                
                return componentData;
            } catch (error) {
                console.error(`Error loading component ${componentId}:`, error);
                throw error;
            }
        }
        
        // Load component for a given model ID (uses server-side lookup)
        async function loadComponentForModel(modelId) {
            // Look up component_id using server-side API
            const componentId = await lookupComponentId(modelId);
            
            if (componentId === null || componentId === undefined) {
                throw new Error(`Model "${modelId}" not found`);
            }
            
            const componentData = await loadComponentById(componentId);
            return componentData;
        }
        
        // Load mini dataset (local file, fast)
        async function loadMiniDataset() {
            try {
                console.log('Loading mini dataset...');
                document.getElementById('loading').textContent = 'Loading mini dataset...';
                
                const response = await fetch('graph_data_mini.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                graphData = await response.json();
                console.log('Mini dataset loaded:', graphData.nodes.length, 'nodes,', graphData.edges.length, 'edges');
                
                document.getElementById('component-info').textContent = 
                    `Mini Sample: ${graphData.nodes.length} nodes, ${graphData.edges.length} edges (zera09/SmolVLM component)`;
                createGraph();
                document.getElementById('loading').style.display = 'none';
                animate();
            } catch (error) {
                console.error('Error loading mini dataset:', error);
                document.getElementById('loading').textContent = `Error loading mini dataset: ${error.message}`;
                document.getElementById('loading').style.display = 'block';
            }
        }
        
        // Initial load: Load mini dataset by default
        async function loadGraphData() {
            // Start with mini dataset (fast, no server calls)
            await loadMiniDataset();
        }
        
        // Note: findConnectedComponent removed - components are now loaded directly from R2
        
        // Create graph visualization
        function createGraph() {
            console.log('Creating graph visualization...');
            
            // Stop animation loop before cleanup to prevent multiple loops
            if (animationId !== null && animationId !== undefined) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            // Clear existing and dispose Three.js resources to prevent memory leaks
            nodeMeshes.forEach(mesh => {
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) {
                    if (Array.isArray(mesh.material)) {
                        mesh.material.forEach(mat => mat.dispose());
                    } else {
                        mesh.material.dispose();
                    }
                }
            });
            
            edgeLines.forEach(line => {
                scene.remove(line);
                if (line.geometry) line.geometry.dispose();
                if (line.material) {
                    if (Array.isArray(line.material)) {
                        line.material.forEach(mat => mat.dispose());
                    } else {
                        line.material.dispose();
                    }
                }
            });
            
            // Clear arrays
            nodeMeshes = [];
            edgeLines = [];
            nodes = [];
            edges = [];
            nodeMap.clear();
            
            // Reset layout state
            layoutStableCount = 0;
            layoutPaused = false;
            lastLayoutUpdate = 0;
            
            // Force garbage collection hint (if available)
            if (window.gc) {
                window.gc();
            }
            
            // If no graph data, return early
            if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
                console.log('No graph data to visualize');
                return;
            }
            
            // Create node map
            graphData.nodes.forEach(node => {
                nodeMap.set(node.id, node);
            });
            
            // Find root nodes (nodes with no incoming edges) for better initial positioning
            const rootNodes = new Set();
            graphData.nodes.forEach(node => {
                const hasIncoming = graphData.edges.some(edge => edge.target === node.id);
                if (!hasIncoming) {
                    rootNodes.add(node.id);
                }
            });
            
            // If no root nodes found, use first node as root
            if (rootNodes.size === 0 && graphData.nodes.length > 0) {
                rootNodes.add(graphData.nodes[0].id);
            }
            
            // Build map of which nodes have children
            const hasChildren = new Set();
            graphData.edges.forEach(edge => {
                hasChildren.add(edge.source);
            });
            
            // Size parameters: nodes with children are 3x the diameter of leaf nodes
            const leafModelSize = CONFIG.nodeBaseSize * 0.5;
            const parentModelSize = leafModelSize * 3.0;
            
            // Create nodes
            graphData.nodes.forEach((nodeData, index) => {
                const isParent = hasChildren.has(nodeData.id);
                const size = isParent ? parentModelSize : leafModelSize;
                
                const geometry = new THREE.SphereGeometry(size, 16, 16);
                const material = new THREE.MeshPhongMaterial({
                    color: isParent ? 0xff6b6b : 0x4ecdc4,
                    emissive: isParent ? 0x330000 : 0x003333,
                    transparent: true,
                    opacity: 0.9
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                
                // Random initial position (will be updated by force simulation)
                mesh.position.set(
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20
                );
                
                mesh.userData = { nodeData, index };
                scene.add(mesh);
                nodeMeshes.push(mesh);
                nodes.push({ mesh, nodeData, velocity: new THREE.Vector3() });
            });
            
            // Create edges
            const edgeOpacity = parseFloat(document.getElementById('edge-opacity').value);
            graphData.edges.forEach(edge => {
                const sourceNode = nodes.find(n => n.nodeData.id === edge.source);
                const targetNode = nodes.find(n => n.nodeData.id === edge.target);
                
                if (!sourceNode || !targetNode) return;
                
                const edgeType = edge.type || 'unknown';
                const color = EDGE_COLORS[edgeType] || EDGE_COLORS['default'];
                
                const geometry = new THREE.BufferGeometry().setFromPoints([
                    sourceNode.mesh.position,
                    targetNode.mesh.position
                ]);
                
                const material = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: edgeOpacity
                });
                
                const line = new THREE.Line(geometry, material);
                line.userData = { edge, edgeType };
                scene.add(line);
                edgeLines.push(line);
            });
            
            // Update stats
            document.getElementById('node-count').textContent = graphData.nodes.length;
            document.getElementById('edge-count').textContent = graphData.edges.length;
            
            // Center camera on graph
            if (nodes.length > 0) {
                const center = new THREE.Vector3();
                nodes.forEach(n => center.add(n.mesh.position));
                center.divideScalar(nodes.length);
                
                camera.position.set(center.x, center.y, center.z + CONFIG.cameraDistance);
                controls.target.copy(center);
                controls.update();
            }
        }
        
        // Simple force-directed layout (returns true if layout is stable)
        function updateLayout() {
            if (nodes.length === 0) return true;
            
            const k = Math.sqrt((nodes.length * 100) / nodes.length);
            const repulsion = 0.1;
            const attraction = 0.01;
            
            let maxVelocity = 0;
            
            // Reset forces
            nodes.forEach(node => {
                node.velocity.multiplyScalar(0.9); // Damping
            });
            
            // Repulsion between all nodes
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const nodeA = nodes[i];
                    const nodeB = nodes[j];
                    const distance = nodeA.mesh.position.distanceTo(nodeB.mesh.position);
                    
                    if (distance > 0) {
                        const force = repulsion / (distance * distance);
                        const direction = new THREE.Vector3()
                            .subVectors(nodeA.mesh.position, nodeB.mesh.position)
                            .normalize()
                            .multiplyScalar(force);
                        
                        nodeA.velocity.add(direction);
                        nodeB.velocity.sub(direction);
                    }
                }
            }
            
            // Attraction along edges
            graphData.edges.forEach(edge => {
                const sourceNode = nodes.find(n => n.nodeData.id === edge.source);
                const targetNode = nodes.find(n => n.nodeData.id === edge.target);
                
                if (!sourceNode || !targetNode) return;
                
                const distance = sourceNode.mesh.position.distanceTo(targetNode.mesh.position);
                if (distance > 0) {
                    const force = (distance - k) * attraction;
                    const direction = new THREE.Vector3()
                        .subVectors(targetNode.mesh.position, sourceNode.mesh.position)
                        .normalize()
                        .multiplyScalar(force);
                    
                    sourceNode.velocity.add(direction);
                    targetNode.velocity.sub(direction);
                }
            });
            
            // Update positions and track max velocity
            nodes.forEach(node => {
                node.mesh.position.add(node.velocity);
                const vel = node.velocity.length();
                if (vel > maxVelocity) maxVelocity = vel;
            });
            
            // Update edge positions
            edgeLines.forEach(line => {
                const edge = line.userData.edge;
                const sourceNode = nodes.find(n => n.nodeData.id === edge.source);
                const targetNode = nodes.find(n => n.nodeData.id === edge.target);
                
                if (sourceNode && targetNode) {
                    line.geometry.setFromPoints([
                        sourceNode.mesh.position,
                        targetNode.mesh.position
                    ]);
                }
            });
            
            // Return true if layout is stable (low velocity)
            return maxVelocity < 0.01;
        }
        
        // Animation loop with throttled force simulation
        let lastLayoutUpdate = 0;
        const LAYOUT_UPDATE_INTERVAL = 100; // Update layout every 100ms instead of every frame (60fps -> 10fps)
        let layoutStableCount = 0;
        const STABLE_THRESHOLD = 20; // Stop layout after 20 stable checks
        let layoutPaused = false;
        
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            // Only update layout if not paused
            if (!layoutPaused) {
                const now = Date.now();
                const shouldUpdateLayout = (now - lastLayoutUpdate) >= LAYOUT_UPDATE_INTERVAL;
                
                if (shouldUpdateLayout) {
                    const wasStable = updateLayout(); // Returns true if layout is stable
                    lastLayoutUpdate = now;
                    
                    if (wasStable) {
                        layoutStableCount++;
                        // Pause layout updates after it's been stable
                        if (layoutStableCount > STABLE_THRESHOLD) {
                            layoutPaused = true;
                            console.log('Layout stabilized, pausing force simulation');
                        }
                    } else {
                        layoutStableCount = 0; // Reset if not stable
                    }
                }
            }
            
            // Always update controls and render (smooth camera movement)
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Handle mouse click
        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodeMeshes);
            
            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object;
                const nodeData = clickedMesh.userData.nodeData;
                
                showNodeInfo(nodeData);
                
                // Highlight selected node
                if (selectedNode) {
                    selectedNode.material.emissive.setHex(selectedNode.userData.nodeData.id === nodeData.id ? 0x000000 : 
                        (hasChildren.has(selectedNode.userData.nodeData.id) ? 0x330000 : 0x003333));
                }
                
                clickedMesh.material.emissive.setHex(0xffff00);
                selectedNode = clickedMesh;
            } else {
                hideNodeInfo();
                if (selectedNode) {
                    const hasChildren = new Set();
                    graphData.edges.forEach(edge => hasChildren.add(edge.source));
                    selectedNode.material.emissive.setHex(
                        hasChildren.has(selectedNode.userData.nodeData.id) ? 0x330000 : 0x003333
                    );
                    selectedNode = null;
                }
            }
        }
        
        // Show node info
        function showNodeInfo(nodeData) {
            const infoPanel = document.getElementById('info-panel');
            document.getElementById('node-name').textContent = nodeData.name || nodeData.id;
            
            const details = [];
            if (nodeData.likes) details.push(`Likes: ${nodeData.likes.toLocaleString()}`);
            if (nodeData.downloads) details.push(`Downloads: ${nodeData.downloads.toLocaleString()}`);
            if (nodeData.pipeline_tag) details.push(`Type: ${nodeData.pipeline_tag}`);
            if (nodeData.library_name) details.push(`Library: ${nodeData.library_name}`);
            
            document.getElementById('node-details').textContent = details.join(' â€¢ ');
            infoPanel.style.display = 'block';
        }
        
        // Hide node info
        function hideNodeInfo() {
            document.getElementById('info-panel').style.display = 'none';
        }
        
        // Setup UI controls
        function setupUIControls() {
            // Data source selector - toggle between mini and full dataset
            const dataSourceSelect = document.getElementById('data-source');
            if (dataSourceSelect) {
                dataSourceSelect.addEventListener('change', async (e) => {
                    const wasFull = useFullDataset;
                    useFullDataset = e.target.value === 'full';
                    
                    if (useFullDataset && !wasFull) {
                        // Switching to full dataset - show message
                        document.getElementById('loading').style.display = 'block';
                        document.getElementById('loading').textContent = 'Switched to full dataset mode. You can now search all models.';
                        setTimeout(() => {
                            document.getElementById('loading').style.display = 'none';
                        }, 2000);
                    } else if (!useFullDataset && wasFull) {
                        // Switching back to mini - reload mini dataset
                        await loadMiniDataset();
                    }
                });
            }
            
            // Search functionality
            const searchInput = document.getElementById('search');
            const searchBtn = document.getElementById('search-btn');
            const autocompleteResults = document.getElementById('autocomplete-results');
            
            let searchTimeout;
            searchInput.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                const query = searchInput.value.toLowerCase().trim();
                
                if (query.length < 2) {
                    autocompleteResults.style.display = 'none';
                    return;
                }
                
                searchTimeout = setTimeout(async () => {
                    // Search using server-side API (no client-side index needed)
                    const matches = await searchModels(query, 10);
                    
                    if (matches.length > 0) {
                        autocompleteResults.innerHTML = matches.map(node => `
                            <div class="autocomplete-item" data-id="${node.id}">
                                <div class="model-id">${highlightMatch(node.id, query)}</div>
                                <div class="model-name">${node.name || ''}</div>
                            </div>
                        `).join('');
                        
                        autocompleteResults.style.display = 'block';
                        
                        // Add click handlers
                        autocompleteResults.querySelectorAll('.autocomplete-item').forEach(item => {
                            item.addEventListener('click', () => {
                                const nodeId = item.dataset.id;
                                searchInput.value = nodeId;
                                autocompleteResults.style.display = 'none';
                                loadComponent(nodeId);
                            });
                        });
                    } else {
                        autocompleteResults.style.display = 'none';
                    }
                }, 300);
            });
            
            searchBtn.addEventListener('click', () => {
                const query = searchInput.value.trim();
                if (query) {
                    loadComponent(query);
                }
            });
            
            // Edge opacity
            document.getElementById('edge-opacity').addEventListener('input', (e) => {
                const opacity = parseFloat(e.target.value);
                document.getElementById('edge-opacity-value').textContent = opacity.toFixed(1);
                edgeLines.forEach(line => {
                    line.material.opacity = opacity;
                });
            });
            
            // Edge type filters
            ['filter-finetune', 'filter-quantized', 'filter-adapter', 'filter-unknown'].forEach(filterId => {
                document.getElementById(filterId).addEventListener('change', updateEdgeVisibility);
            });
        }
        
        // Load component for a given model ID (async, loads from R2 or mini dataset)
        async function loadComponent(nodeId) {
            if (!useFullDataset) {
                // In mini mode, just search within the loaded mini dataset
                if (!graphData || !graphData.nodes) {
                    alert('Mini dataset not loaded. Please wait for it to load.');
                    return;
                }
                
                const node = graphData.nodes.find(n => n.id === nodeId);
                if (!node) {
                    alert(`Model "${nodeId}" not found in mini dataset. Switch to "Full Dataset" to search all models.`);
                    return;
                }
                
                // Mini dataset is already loaded, just show info
                document.getElementById('component-info').textContent = 
                    `Mini Sample: ${graphData.nodes.length} nodes, ${graphData.edges.length} edges`;
                createGraph();
                return;
            }
            
            // Full dataset mode - use server-side lookup API
            
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loading').textContent = `Loading component for ${nodeId}...`;
            
            try {
                graphData = await loadComponentForModel(nodeId);
                
                document.getElementById('component-info').textContent = 
                    `Component: ${graphData.nodes.length} nodes, ${graphData.edges.length} edges (${nodeId})`;
                
                createGraph();
                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                alert(`Model "${nodeId}" not found: ${error.message}`);
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        // Update edge visibility based on filters
        function updateEdgeVisibility() {
            const showFinetune = document.getElementById('filter-finetune').checked;
            const showQuantized = document.getElementById('filter-quantized').checked;
            const showAdapter = document.getElementById('filter-adapter').checked;
            const showUnknown = document.getElementById('filter-unknown').checked;
            
            edgeLines.forEach(line => {
                const edgeType = line.userData.edgeType || 'unknown';
                let visible = false;
                
                if (edgeType === 'finetune' && showFinetune) visible = true;
                else if (edgeType === 'quantized' && showQuantized) visible = true;
                else if (edgeType === 'adapter' && showAdapter) visible = true;
                else if (showUnknown) visible = true;
                
                line.visible = visible;
            });
        }
        
        // Highlight search match in text
        function highlightMatch(text, query) {
            const index = text.toLowerCase().indexOf(query.toLowerCase());
            if (index === -1) return text;
            
            return text.substring(0, index) +
                   `<span class="highlight">${text.substring(index, index + query.length)}</span>` +
                   text.substring(index + query.length);
        }
        
        // Start the application
        init();
    </script>
</body>
</html>

